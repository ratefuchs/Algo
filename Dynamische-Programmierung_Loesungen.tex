\documentclass{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{enumerate}

\begin{document}
\section*{Lösungen zum Thema dynamische Programmierung}
\begin{enumerate}[(1)]

\item Mit dynamischer Programmierung wird verhindert, dass überlappende Teilprobleme eines Optimierungsproblems unnötig mehrfach gelöst werden. Dafür werden die Teillösungen zwischengespeichert, um sie wiederverwenden zu können.

\item\begin{enumerate}[(a)]
\item Lösungsvorschlag:\begin{verbatim}FACTORIAL(n)
//sei f[0..n] ein neues Feld
f[0] = 0;
for i = 1 to n
    f[i] = f[i – 1] * i;
return f[n];
\end{verbatim}
\item Da das dynamische Programm während der Bearbeitung alle Zwischenergebnisse $k!\quad (k \leq n)$ bereits in der Tabelle f speichert, muss nur dafür gesorgt werden, dass diese auch nach dem Ablauf der Methode erhalten bleibt. In jedem weiteren Aufruf für $k!\quad (k \leq n)$ kann nun durch einfaches Auslesen des Werts f[k] das Ergebnis geliefert werden.
\end{enumerate}

\item Lösungsvorschlag:\begin{verbatim}BINOMIAL(n, k)
//sei b[0..n][0..k] ein neues Feld
for i = 0 to n
    for j = 0 to k
        if (j > i)
            b[i][j] = 0;
        else if (j == 0 or i == j)
            b[i][j] = 1;
        else
            b[i][j] = b[i – 1][k – 1] + b[i – 1][k];
return b[n][k];
\end{verbatim}

\end{enumerate}
\end{document}